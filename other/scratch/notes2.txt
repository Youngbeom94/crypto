# one advantage of a block cipher is state size: you can get away with an 80-128 bit block size
#   - you can also use less rounds then a hash
# a stream cipher should have a block size twice the key
#   - at least 80 bits of key material implies at least 160 bits of state
# a hash function needs 256+ bits of state and lots of rounds



iv = g
a = r1
b = r2
h_a = one_way_function(iv, a)
h_b = one_way_function(iv, b)
h_ab = one_way_function(h_b, a)
h_ab = one_way_function(h_a, b)

one way function such that h(h(iv, k1), h(iv, k2)) == h(h(iv, k2), h(iv, k1))
branch(m) ^ branch(k1)
branch(m) ^ branch(k2)


#h_1(m) || h_2(m) improves collision resistance
#h_2(h_1(m)) improves preimage resistance

#h_2(h_1(h_1(m) || h_2(m))) ?

# non-reversible cryptography will always be vulnerable to side channel analysis because of the information radiating in the form of heat when information is not preserved in the non-reversible circuit. Every non-reversibly evaluated xor gate leaks information in the form of heat.







cipher design strategies
First, you have to establish
"The simple" - RC4 like (shuffling huge array of words)

"The small" - 8-bit friendly/constrained device friendly.

"The fast" - salsa like (SIMD with big registers)



What is diffusion, anyways?
----
job of diffusion: spread inputs to many different s-boxes
    - how to maximize diffusion?
        - placing *every* term as input to *every* s-box is actually not ideal
            - this means that the outputs of every s-box will be identical
    - so what is the optimal maximum number of terms to appear in the given number of s-boxes?
        - need to take into account:
            - total number of terms: k
            - total number of s-box applications: n
        - ideally: 50% of the input bits should influence any given output bit
            - insert branch8 as example
            - ideally, the distribution of the input bits should be randomly distributed
            - so each input bit should appear as input to 1/2 of the total s-boxes
        - each term should appear in n/2 s-boxes
        - each s-box should have as input k/2 terms
    
    
            
So what is confusion? What even are s-boxes, anyways?
--------
An "s-box" is really a "non-linear function evaluator"
What is a non-linear function? 
    - TODO -------------------------------
    
Why do we require non-linear functions?
    - A linear equation is easily solved, given a few input output pairs
        - This applies even with an arbitrary number of rounds
        - insert shuffle-key-diffuse example
    - Non-linear equations are harder to work with, algebraically
    - We ultimately want a system of equations that is prohibitively complex, with many terms of high degree
         
"active s-boxes" = non-linear equations that are different, between two pairs of states
    - the "non-active" s-boxes have identical terms between the two pairs of states
worst case: no diffusion: AES with no mix columns; each 8-bit word is described by one distinct equation, with no other words mixed in
So "diffusion" revisited: spreading around inputs to different "non-linear function evaluators" (the "s-box" that is applied in parallel on the state)

what degree is sufficient? How non-linear does it need to be?

 1 -> 2 = 3
 2 -> 4 = 6 = 9
 4 -> 8 = 12 = 21
 8 -> 16 = 24 = 45
 16 -> 32 = 48 = 93
 32 -> 64 = 96 = 189
 64 -> 128 = 192 = 381
 
 
 
            
# 0 1 2 3 # a ^= rotate_left(a, 1)
# 1 2 3 0
# 01 12 23 03 # good - each bit appears in 2 places

# 01 12 23 03  # 1 and 1
# 12 23 03 01 
# 02 13 02 13 # not good - repetitive patterns


# 01 12 23 03 # 1 and 2
# 23 03 01 12 
# 0123 0123 0123 # not good - all identical


# 01 12 23 03 # 1 and 3
# 03 01 12 23
# 13 02 13 02 # still not good


 
# 0 1 2 3 # a ^= rotate_left(a, 2)
# 2 3 0 1
# 02 13 02 13


# 0 1 2 3 # a ^= rotate_left(a, 3)
# 3 0 1 2
# 03 01 12 23


# for a function: 50% is ideal


# for a permutation:

# 0 1   # a ^= b
# 2 3
# 02 13

#  3  2     # b ^= rotate_left(a, 1)
# 02 13 
# 023 123

# 02 13
# 023 123





# 02 13
# 2 3

# 01 23




# error correcting code based diffusion test?
# establish an 8-1-d code for the linear layer
# > d == better diffusion

# bivs diffusion test :)



            