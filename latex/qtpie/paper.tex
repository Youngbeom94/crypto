\documentclass[preprint]{iacrtrans}
\usepackage[utf8]{inputenc}

% Select what to do with todonotes: 
% \usepackage[disable]{todonotes} % notes not showed
\usepackage[draft,color=orange!20!white,linecolor=orange,textwidth=3cm,colorinlistoftodos]{todonotes}   % notes showed
\setlength{\marginparwidth}{3cm}
\usepackage{graphicx}
\usepackage{soul}
\graphicspath{{images/}} % end dirs with `/'
% \usepackage{longtable}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows}
\usetikzlibrary{crypto.symbols}
\tikzset{shadows=no}        % Option: add shadows to XOR, ADD, etc.

\author{Ella Rose}
\institute{Paso Robles, CA \email{python_pride@protonmail.com}}
\title[LWE Trapdoor One-Way Function]{LWE Trapdoor One-Way Function}

\begin{document}

\maketitle

% use optional argument because the \LaTeX command breaks the PDF keywords
\keywords[Homomorphic Encryption, Public Key Cryptography]{Homomorphic Encryption, Public Key Cryptography}

\begin{abstract}
 We define a simple trapdoor function based on the Learning-With-Errors problem in one dimension, and present a key exchange algorithm based on the trapdoor. The trapdoor algorithm is efficient in terms of key size, key generation time, ciphertext size, and public/private key operation time: We can perform many thousands of public and private key operations per second with a naive python implementation on modest hardware. 
 \end{abstract}

\todototoc
\listoftodos
You are missing all the non fake signature etc.

You should use the environment algorithm to write your algorithm. It is difficult to understand as is.

Addition over what field ? Etc for the rest. (edited)

What key sizes? Why k private is 520 bits ?

How does all this compares to others methods ?

\section{Introduction}
A Trapdoor One-Way Function (TOWF) is a function that is easy for anyone to compute in one direction, but is hard to compute in reverse without some additional piece of information. TOWFs are useful for cryptography, because they make constructing various public key primitives a relatively straightforward exercise.

The Learning-With-Errors (LWE) problem is a mathematical problem that is believed to be difficult to solve efficiently even with a quantum computer. A 1-dimensional LWE problem takes the form $a s + e \mod P$, where $a, P$ are known and $s, e$ are secret, random values.

In this paper we define a candidate TOWF based on 1-dimensional LWE. It is based on a simple observation of a congruence, $a s + e \equiv s + a^{-1} e \mod P$, along with some subtle manipulation of the sizes of the numbers involved. The trapdoor information is the short inverse $a^{-1}$, which allows the recovery of $s, e$ from a point $a s + e \mod P$, provided some constraints on the sizes of numbers are satisfied.

We use the TWOF to construct basic public key algorthims for exchanging keys and creating digital signatures.

\subsection{Definitions}
We $+$ to denote addition, $a b$ to indicate multiplication, $a / b$ to denote division, and $\mod p$ to denote the modulo operation. We use $\leftarrow$ to indicate the assignment of a value to a name, and $\rightarrow$ to indicate the sending of data from one party to another. We use the function $inverse(k, n)$ to indicate the computation of the modular multiplicative inverse of $k \mod n$. We use the function $random(k)$ to indicate the generation of of a random $k$-bit integer. We write application of the public key operation as $key_{pub}(s,\ e)$, and application of the private key operation as $key_{priv}(c)$.

\section{Algorithm}
There is a publicly agreed upon modulus $P$. All math is done modulo $P$. The same $P$ may always be used. It should be prime; It it is not secret, and otherwise only needs to be both agreed upon and large enough. The size of $P$ is determined by the rest of the parameter sizes which are discussed below; In our python implementation which targets a 256-bit security level, $P$ is slightly less then 800 bits in size. The larger $P$ is, the longer the BigNum arithmetic operations take, and the larger ciphertexts become; Consequently, we opt for the smallest $P$ possible.

\subsection{Design Outline}
Consider the following expression:

\begin{flalign*}
c \leftarrow a s + e \mod P
\end{flalign*}

Given $c, p, N$, we can recover $s, e$ using the following algorithm:

\begin{flalign*}
t \leftarrow a^{-1} c\\
s \leftarrow t \mod a^{-1}\\
t \leftarrow t - s \\
e \leftarrow t / a^{-1}
\end{flalign*}

Where $a^{-1}$ is the output of $inverse(a, P)$.

The step $s \leftarrow t \mod a^{-1}$ will only function correctly if $s < a^{-1}$ and if $a^{-1} e < P$. We leverage this latter fact to create the trapdoor: We select a suitable $a^{-1}$ that is large enough such that $s < a^{-1}$ and small enough such that $a^{-1} e < P$. Then, we calculate the modular multilicative inverse $a \leftarrow inverse(a^{-1}, P)$. This number will likely be very large, closer to $P$ in size then to $a^{-1}$. To create a public key, we then encrypt $a$ using a random $r$ to preclude the ability of others to calculate $a^{-1}$. 

The public key provides the ability to compute the forward operation $a s + e \mod P$ because there is no size constraint on $a$ for this operation to function (as long as $a < P$ anyways). Supplying the inverse of the public key to the inversion algorithm will not produce correct plaintext, because the generated value will be too large. We can witness this via the attempt below:

\begin{flalign*}
key_{pub} \leftarrow a r\\
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow key_{pub} s + e\\
key_{pub}^{-1} \leftarrow inverse(key_{pub}, P)\\
c_i \leftarrow c key_{pub}^{-1}\\
c_i \equiv s + a^{-1} r^{-1} e\\
\end{flalign*}

In the final line $c_i \equiv s + a^{-1} r^{-1} e$, we can see that the inverse of the public key is too large if $a^{-1} r^{-1} e > P$; In such a case, $s + a^{-1} r^{-1} e \mod a^{-1} r^{-1}$ will not yield $s$; While $a^{-1}$ is relatively small, $r^{-1}$ is (most likely) large - Ultimately, the size of $a^{-1} r^{-1}$ is roughly the same as $a r$, and so this alternative perspective of $s + a^{-1} r^{-1} e$ offers no more advantage to recovering $s, e$ as then the original $ars + e$ did.

This is in contrast to the perspective that the holder of $a^{-1}$ has:

\begin{flalign*}
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow key_{pub}s + e\\
c_i \leftarrow c a^{-1}\\
c_i \equiv sr + a^{-1} e
\end{flalign*}

We can see the difference in the final line $c_i \equiv sr + a^{-1} e$ from before; While the $r$ variable is still present on the left term, $a^{-1} e < N$ and so $sr + a^{-1} e \mod a^{-1}$ will yield $sr$ and the inversion algorithm will work as intended. The presence of the $r$ variable on the left does require that $a^{-1}$ be larger to ensure that $sr < a^{-1}$.

\subsection{Key Generation}
\begin{flalign*}
key_{priv} \leftarrow random(priv_{size})\\
a \leftarrow inverse(key_{priv}, N)\\
r \leftarrow random(r_{size})\\
k_{pub} \leftarrow a r\\
\end{flalign*}

For the trapdoor to function correctly, $priv_{size}$ must be selected such that $e k_{priv} < P$, as well as $k_{priv} > r s$, where $s, e$ are the security parameters of the public key operation. For 256-bit $e, r, s$ values, $priv_{size}$ is 520 bits, while $P$ is 783 bits.

\subsection{Public Key Operation}
\begin{flalign*}
a \leftarrow key_{pub}\\
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow a s + e\\
\end{flalign*}

\subsection{Private Key Operation}

\begin{flalign*}
t \leftarrow a^{-1} c\\
sr \leftarrow t \mod a^{-1}\\
t \leftarrow t - sr\\
s \leftarrow sr r^{-1}\\
e \leftarrow t a\\
output\ s,\ e
\end{flalign*}

Either $s, e$ or a combination of both may be used in different contexts to achieve different effects.

\subsection{Homomorphism}
Two ciphertexts of the form $a s + e$ may be added together to yield $a (s_1 + s_2) + e_1 + e_2$. 
Ciphertexts may be multiplied by plaintext scalars - this follows from the previous property, as $c + c \equiv 2c$.
Additionally, adjustments may be made to the value of $e$ via addition/subtraction with a plaintext scalar: $a s + e + r$.

It should be noted that multiplication will quickly increase the size of the terms in the expressions, and if the size of the terms grows too large, decryption will fail.

\section{Key Exchange and Digital Signatures}
\subsection{Key Exchange}
Given a TWOF, a basic algorithm to exchange keys can be constructed as follows: Assuming that Alice has Bob's public key already, she simply applies the public key operation to a random value and sends the result to Bob; Bob can then use the private key to recover the random value. Assuming that both parties are honest, then the random value will be unknown to all parties but Alice and Bob, and they can use this information to construct a secured communications channel.

The basic mechanism presented in this section is not sufficient for constructing a general purpose secure communications protocol - for example, authentication is not addressed. The construction of such protocols is outside of the scope of this paper. 

\subsection{Digital Signatures}
A TWOF can serve as a fundamental part of a digital signature scheme: The private key operation can be used to produce a preimage for a given ciphertext, and the corresponding public key can be used to check if the preimage outputs the challenge ciphertext. 

We note that ciphertexts produced by the TWOF are additively homomorphic - this means that signatures will possess this quality as well. This feature can be removed by signing a hash of the message instead of the message itself.

\section{Security Analysis}
There are two main goals: First, given the public key, the private key must not be obtainable; Second, The output of the public key operation must not be invertible without the private key.

There is a third goal that is only applicable in the context of digital signatures: The output of the private key operation must not leak the private key. This goal is not applicable in the context of key exchange, because the adversary does not see the output of the private key operation.

\subsection{Key Generation}
It would appear that obtaining the private key from the public key must be done by guessing one of $a, a^{-1}, r$. If this were not the case, then whatever algorithm that can be used to recover any of $a, a^{-1}, r$ from $a r \mod P$ could be used to recover plaintexts from ciphertexts of the form $m k \mod P$ for random $m, k$ where one of $m, k$ is smaller then the other (but still large enough to reduce modulo $P$). It seems unlikely that such an attack exists and is faster then guessing $a, a^{-1},  r$. 

This implies that there does not exist an algorithm to recover the private key from the public key, other then brute force guessing.

\subsection{Public Key Operation}
The public key operation appears to be a 1-dimensional version of the learning-with-errors problem.\\

If we consider the case where $ar = 1$, then $ars + e \equiv s + e \mod P$ for uniformly random values $s, e$. 

\subsection{Private Key Operation}
Utilizing the TWOF here as a signature function does not provide the same confidence as using the TWOF for key exchange: With the private key operation, the expressions do not take the form of the LWE problem. Despite this, it is not obvious to us how to take advantage of this fact to recover the private key.

\subsection{Side Channel Analysis}
Assuming that BigNum operations can be implemented in a manner that does not leak timing information, it appears that a naive implementation of the algorithm is resistant to timing side channel analysis, as there are no tables or branches in the algorithm.

\section{Metrics}
Using our public domain python implementation that is configured for a 256-bit security level, we can perform 10,000 public key operations in slightly under 1 second. We can perform roughly 30,000 private key operations per second. Our tests were performed on modest hardware, namely an Intel Celeron N2830 2.16GHz with 2 cores. 

In our implementation, most of the time for the public key operation is spent generating $s$ and $e$. In a synthetic test where $s, e$ are not generated for each invocation of the function, we can perform 100,000 public key operations per second.

Our implementation is optimized for readability. Much of the computation time is spent on bignum operations, and while an optimized C implementation may certainly be faster, it is not required to obtain an acceptable level of performance in the context of hybrid cryptosystems. 

\subsection{Implementation Complexity}
The implementation complexity of the scheme is very low. Our public domain python implementation of the algorithm spans barely 100 lines, including the documentation and comments.\\

Additional code is required for supporting functions such as the generation of prime numbers (only if $N$ is being generated/not already established) and unit testing. These are modest requirements that can be implemented without much complexity. \\

\section{Conclusion}
We define a conceptually simple, resource-practical Trapdoor One-Way Function. 
\end{document}

